"""
Symbolic Execution Engine
符号执行引擎

This module executes the computational plan generated by the causal scaffolder
using symbolic mathematics (SymPy) to ensure perfect numerical accuracy.

本模块使用符号数学（SymPy）执行由因果脚手架生成的计算计划，
以确保完美的数值精度。
"""

import sympy as sp
from typing import Dict, List, Any, Optional, Union
from copy import deepcopy


class ExecutionError(Exception):
    """
    Custom exception for execution errors.
    执行错误的自定义异常
    """
    pass


class SymbolicExecutor:
    """
    Symbolic Execution Engine for solving causal computation plans.
    用于求解因果计算计划的符号执行引擎

    This class takes a structured JSON plan and executes it step-by-step
    using SymPy for symbolic mathematics, ensuring computational precision.

    此类获取结构化的JSON计划并使用SymPy逐步执行以进行符号数学计算，
    确保计算精度。
    """

    def __init__(self, precision: int = 15):
        """
        Initialize the symbolic executor.
        初始化符号执行器

        Args:
            precision: Number of decimal places for numerical precision (default: 15)
                       数值精度的小数位数（默认：15）
        """
        # Storage for intermediate results
        # 存储中间结果
        self.variables: Dict[str, Union[float, int]] = {}
        self.step_results: Dict[str, Union[float, int]] = {}

        # Precision configuration / 精度配置
        self.precision = precision
        self.epsilon = 10 ** (-precision)  # Tolerance for comparisons / 比较的容差

    def execute_plan(self, causal_scaffold: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Execute a causal computation plan.
        执行因果计算计划

        This is the main entry point that processes the entire scaffold,
        executing each step in the computation plan sequentially.

        这是处理整个脚手架的主入口点，按顺序执行计算计划中的每一步。

        Args:
            causal_scaffold: The structured causal model JSON
                             结构化的因果模型JSON

        Returns:
            The scaffold with added 'results' field, or None if execution fails
            添加了'results'字段的脚手架，如果执行失败则返回None
        """
        # Reset state / 重置状态
        self.variables = {}
        self.step_results = {}

        # Create a deep copy to avoid modifying the original
        # 创建深拷贝以避免修改原始数据
        executed_scaffold = deepcopy(causal_scaffold)

        print("Starting symbolic execution...")
        print("开始符号执行...")

        try:
            # Load known variables from scaffold
            # 从脚手架加载已知变量
            self.variables = dict(causal_scaffold.get("knowns", {}))

            # Execute each step in the computation plan
            # 执行计算计划中的每一步
            computation_plan = causal_scaffold.get("computation_plan", [])
            causal_graph = causal_scaffold.get("causal_graph", [])

            for step in computation_plan:
                self._execute_step(step, causal_graph, computation_plan)

            # Add results to the scaffold
            # 将结果添加到脚手架
            executed_scaffold["results"] = self.step_results

            # Add final answer
            # 添加最终答案
            target_var = causal_scaffold.get("target_variable")
            if target_var in self.variables:
                executed_scaffold["final_answer"] = self.variables[target_var]
            else:
                print(f"Warning: Target variable '{target_var}' not found in results.")
                print(f"警告: 在结果中未找到目标变量 '{target_var}'")

            print("Symbolic execution completed successfully.")
            print("符号执行成功完成")

            return executed_scaffold

        except Exception as e:
            print(f"Execution error: {e}")
            print(f"执行错误: {e}")
            return None

    def _execute_step(
        self,
        step: Dict[str, Any],
        causal_graph: List[Dict[str, Any]],
        computation_plan: List[Dict[str, Any]] = None
    ) -> None:
        """
        Execute a single step in the computation plan.
        

        Args:
            step: The step definition from computation_plan
                   computation_plan 
            causal_graph: The causal graph defining relationships
                          
            computation_plan: The full computation plan (for resolving step references)
                              

        Raises:
            ExecutionError: If the step cannot be executed
                            
        """
        step_id = step.get("id")
        operation = step.get("operation")
        target = step.get("target")
        inputs = step.get("inputs", [])
        tool = step.get("tool")

        print(f"Executing step: {step_id} - {operation} for {target}")
        print(f": {step_id} -  {target}  {operation}")

        # Resolve input values
        # 
        input_values = self._resolve_inputs(inputs, computation_plan)

        # Find the relevant rule from the causal graph
        # 
        rule = self._find_rule(target, causal_graph)

        if not rule:
            raise ExecutionError(
                f"No rule found for target variable: {target}\n"
                f": {target}"
            )

        # Execute based on operation type
        #
        if operation == "solve_for":
            if tool == "symbolic_solver":
                result = self._symbolic_solve(target, rule, input_values)
            else:
                raise ExecutionError(
                    f"Unsupported tool for solve_for operation: {tool}\n"
                    f"solve_for : {tool}"
                )
        elif operation == "evaluate":
            result = self._evaluate_expression(target, rule, input_values)
        elif operation == "simplify":
            result = self._simplify_expression(target, rule, input_values)
        elif operation == "compute":
            # Alias for evaluate
            # evaluate 
            result = self._evaluate_expression(target, rule, input_values)
        else:
            raise ExecutionError(
                f"Unsupported operation: {operation}\n"
                f": {operation}"
            )

        # Validate the result
        # 
        self._validate_result(target, result, input_values)

        # Store the result
        # 
        self.step_results[step_id] = result
        self.variables[target] = result

        print(f"  Result: {target} = {result}")
        print(f"  : {target} = {result}")

    def _resolve_inputs(
        self,
        inputs: List[Union[str, Dict[str, str]]],
        computation_plan: List[Dict[str, Any]] = None
    ) -> Dict[str, Union[float, int]]:
        """
        Resolve input values from variable names or step references.
        

        Args:
            inputs: List of input specifiers (strings or {"ref": "step_id.output"})
                     {"ref": "step_id.output"}
            computation_plan: The computation plan (optional, for resolving step references)
                              

        Returns:
            Dictionary mapping variable names to their values
            

        Raises:
            ExecutionError: If an input cannot be resolved
                            
        """
        resolved = {}

        for inp in inputs:
            if isinstance(inp, str):
                # Direct variable reference
                # 
                if inp in self.variables:
                    resolved[inp] = self.variables[inp]
                else:
                    raise ExecutionError(
                        f"Variable '{inp}' not found in known variables.\n"
                        f" '{inp}'"
                    )

            elif isinstance(inp, dict) and "ref" in inp:
                # Reference to a previous step's output
                # 
                ref = inp["ref"]  # Format: "step_id.output" or just "step_id"
                step_id = ref.split(".")[0]

                if step_id not in self.step_results:
                    raise ExecutionError(
                        f"Step '{step_id}' result not found.\n"
                        f" '{step_id}' "
                    )

                # Find the target variable for this step
                # 
                target_var = None
                if computation_plan:
                    for step in computation_plan:
                        if step.get("id") == step_id:
                            target_var = step.get("target")
                            break

                if target_var and target_var in self.variables:
                    resolved[target_var] = self.variables[target_var]
                    print(f"  Resolved step reference '{ref}' to {target_var} = {self.variables[target_var]}")
                    print(f"   '{ref}'  {target_var} = {self.variables[target_var]}")
                else:
                    # Fallback: use the step result directly with a generated name
                    # 
                    result_value = self.step_results[step_id]
                    var_name = f"{step_id}_result"
                    resolved[var_name] = result_value
                    print(f"  Resolved step reference '{ref}' to {var_name} = {result_value}")
                    print(f"   '{ref}'  {var_name} = {result_value}")

            else:
                raise ExecutionError(
                    f"Invalid input format: {inp}\n"
                    f": {inp}"
                )

        return resolved

    def _find_rule(self, target: str, causal_graph: List[Dict[str, Any]]) -> Optional[str]:
        """
        Find the causal rule for a target variable.
        

        Args:
            target: The variable to find a rule for
                    
            causal_graph: The causal graph
                          

        Returns:
            The rule string, or None if not found
             None
        """
        for link in causal_graph:
            if link.get("effect") == target:
                return link.get("rule")
        return None

    def _symbolic_solve(
        self,
        target: str,
        rule: str,
        input_values: Dict[str, Union[float, int]]
    ) -> Union[float, int]:
        """
        Solve for a target variable using symbolic mathematics.
        

        This method parses the rule equation and uses SymPy to solve for
        the target variable given the input values.

         SymPy 

        Args:
            target: The variable to solve for
                    
            rule: The equation or formula (e.g., "F = m * a")
                   "F = m * a"
            input_values: Dictionary of known variable values
                          

        Returns:
            The numerical result for the target variable
            

        Raises:
            ExecutionError: If the equation cannot be parsed or solved
                            
        """
        try:
            # Parse the equation from the rule
            # 
            equation = self._parse_equation(rule)
            print(f"  Parsed equation: {equation}")
            print(f"  : {equation}")

            # Extract variables that actually appear in the equation
            # 
            import re
            # Match variables: Greek letters (with optional suffix) OR regular identifiers
            # 
            equation_vars = set(re.findall(r'[Δθπρσμλφψωαβγδεζηικνξοτυχρ]+[a-zA-Z_0-9]*|[a-zA-Z_][a-zA-Z0-9_]*', equation, re.UNICODE))

            # Create SymPy symbols for all variables in the equation
            #  SymPy 
            symbols_dict = self._create_symbols(equation, target, input_values)
            print(f"  Equation variables: {list(equation_vars)}")
            print(f"  : {list(equation_vars)}")
            print(f"  All symbols: {list(symbols_dict.keys())}")
            print(f"  : {list(symbols_dict.keys())}")
            print(f"  Input values: {input_values}")
            print(f"  : {input_values}")

            # Create a SymPy equation
            #  SymPy 
            lhs, rhs = equation.split("=")
            lhs_expr = sp.sympify(lhs.strip(), locals=symbols_dict)
            rhs_expr = sp.sympify(rhs.strip(), locals=symbols_dict)
            print(f"  LHS: {lhs_expr}, RHS: {rhs_expr}")
            print(f"  : {lhs_expr}, : {rhs_expr}")

            # Substitute known values from input_values with variable mapping
            #  input_values
            for var_name, var_value in input_values.items():
                # Find the actual variable name used in equation
                #
                eq_var = self._find_variable_in_equation(var_name, equation_vars)
                if eq_var and eq_var in symbols_dict:
                    lhs_expr = lhs_expr.subs(symbols_dict[eq_var], var_value)
                    rhs_expr = rhs_expr.subs(symbols_dict[eq_var], var_value)
                    print(f"  Substituted: {var_name} ({eq_var} in equation) = {var_value}")
                    print(f"  : {var_name} ( {eq_var}) = {var_value}")

            # Special handling for division by zero in trigonometric functions
            #
            # Check if expression contains atan(a/b) where b might be zero
            # atan(a/b) b
            import math as pymath
            rhs_str = str(rhs_expr)
            if 'atan' in rhs_str and '/' in rhs_str:
                # Try to extract the atan argument and check for division by zero
                # atan
                try:
                    # Get all atan function calls
                    # atan
                    atan_funcs = [arg for arg in sp.preorder_traversal(rhs_expr) if isinstance(arg, sp.atan)]
                    for atan_func in atan_funcs:
                        atan_arg = atan_func.args[0]  # Get the argument of atan
                        # Check if it's a division
                        #
                        if isinstance(atan_arg, sp.Mul) or '/' in str(atan_arg):
                            # Evaluate the atan argument
                            # atan
                            try:
                                arg_val = atan_arg.evalf()
                                # Check if we got infinity (division by zero)
                                #
                                if arg_val == sp.oo:  # Positive infinity
                                    result = pymath.pi / 2
                                    print(f"  Special case: atan(infinity) = pi/2")
                                    print(f"  : atan() = pi/2")
                                    return result
                                elif arg_val == -sp.oo:  # Negative infinity
                                    result = -pymath.pi / 2
                                    print(f"  Special case: atan(-infinity) = -pi/2")
                                    print(f"  : atan(-) = -pi/2")
                                    return result
                            except:
                                pass
                except:
                    pass

            # Also substitute any other known variables from self.variables with mapping
            #  self.variables 
            for var_name, var_value in self.variables.items():
                eq_var = self._find_variable_in_equation(var_name, equation_vars)
                if eq_var and eq_var in symbols_dict and var_name not in input_values:
                    #  input_values 
                    lhs_expr = lhs_expr.subs(symbols_dict[eq_var], var_value)
                    rhs_expr = rhs_expr.subs(symbols_dict[eq_var], var_value)
                    print(f"  Auto-substituted: {var_name} ({eq_var} in equation) = {var_value} (from previous steps)")
                    print(f"  : {var_name} ( {eq_var}) = {var_value} ()")

            # Solve for the target variable with mapping
            # 
            # Find the actual target symbol in the equation
            # 
            eq_target = self._find_variable_in_equation(target, equation_vars)
            if eq_target and eq_target in symbols_dict:
                target_symbol = symbols_dict[eq_target]
                print(f"  Solving for: {target} (represented as '{eq_target}' in equation)")
                print(f"  : {target} ( '{eq_target}')")
            else:
                # Find the unknown symbol (the one not in input_values)
                #  input_values 
                # Get symbols that haven't been substituted
                substituted_vars = set()
                for var_name in list(input_values.keys()) + list(self.variables.keys()):
                    eq_var = self._find_variable_in_equation(var_name, equation_vars)
                    if eq_var:
                        substituted_vars.add(eq_var)

                unknown_vars = equation_vars - substituted_vars
                if not unknown_vars:
                    raise ExecutionError(
                        f"Cannot find unknown variable to solve for in equation: {rule}\n"
                        f": {rule}"
                    )
                eq_target = list(unknown_vars)[0]
                target_symbol = symbols_dict[eq_target]
                print(f"  Note: Solving for symbol '{eq_target}' (inferred from equation)")
                print(f"  :  '{eq_target}'")
            
            equation_to_solve = sp.Eq(lhs_expr, rhs_expr)
            solution = sp.solve(equation_to_solve, target_symbol)

            if not solution:
                raise ExecutionError(
                    f"No solution found for {target} in equation: {rule}\n"
                    f" {target} : {rule}"
                )

            # Check if solution contains AccumBounds (happens with atan division by zero)
            # AccumBounds atan
            if solution and 'AccumBounds' in str(type(solution[0])):
                print(f"  Got AccumBounds, attempting limit-based evaluation")
                print(f"  AccumBounds")
                # Try to evaluate the RHS directly (target is isolated on LHS)
                # RHS LHS
                try:
                    # For equations like theta = atan(y/x), just evaluate atan(y/x) with limit
                    # theta = atan(y/x) atan(y/x) limit
                    result_val = rhs_expr.evalf()
                    if 'AccumBounds' in str(type(result_val)):
                        # Use the midpoint of the bounds as approximation
                        #
                        if hasattr(result_val, 'mid'):
                            result = float(result_val.mid.evalf())
                            print(f"  Using bounds midpoint: {result}")
                            print(f"  : {result}")
                            return result
                except:
                    pass

            # Extract the numerical result with multiple solution handling
            # 
            result = self._select_physical_solution(solution, target, eq_target if 'eq_target' in locals() else target)
            return result

        except ExecutionError:
            # Re-raise ExecutionErrors as-is
            #  ExecutionError
            raise
        except sp.SympifyError as e:
            raise ExecutionError(
                f"Failed to parse equation for '{target}'.\n"
                f"Rule: {rule}\n"
                f"Parse error: {e}\n"
                f"Hint: Check equation syntax and variable names.\n"
                f" '{target}' \n"
                f": {rule}\n"
                f": {e}\n"
                f": "
            )
        except (ValueError, TypeError) as e:
            raise ExecutionError(
                f"Failed to solve equation for '{target}'.\n"
                f"Rule: {rule}\n"
                f"Input values: {input_values}\n"
                f"Error: {e}\n"
                f"Hint: Check that all required variables are provided and have valid values.\n"
                f" '{target}' \n"
                f": {rule}\n"
                f": {input_values}\n"
                f": {e}\n"
                f": "
            )
        except Exception as e:
            raise ExecutionError(
                f"Unexpected error solving equation for '{target}'.\n"
                f"Rule: {rule}\n"
                f"Input values: {input_values}\n"
                f"Error type: {type(e).__name__}\n"
                f"Error: {e}\n"
                f" '{target}' \n"
                f": {rule}\n"
                f": {input_values}\n"
                f": {type(e).__name__}\n"
                f": {e}"
            )

    def _select_physical_solution(
        self,
        solutions: list,
        target_var: str,
        equation_var: str
    ) -> Union[float, int]:
        """
        Select the physically reasonable solution from multiple solutions.
        

        Args:
            solutions: List of solutions from SymPy solve
                       SymPy
            target_var: The target variable name
                        
            equation_var: The variable name in equation
                          

        Returns:
            The selected numerical solution
            

        Raises:
            ExecutionError: If no physically valid solution exists
                            
        """
        # Convert all solutions to float, filtering out complex numbers
        #
        real_solutions = []
        for sol in solutions:
            try:
                # Check for AccumBounds (happens with division by zero in atan, etc.)
                # AccumBounds atan
                if 'AccumBounds' in str(type(sol)):
                    print(f"  Warning: Got AccumBounds result {sol}, skipping")
                    print(f"  : AccumBounds {sol}")
                    continue

                # Check if solution is real
                #
                if sol.is_real or (hasattr(sol, 'evalf') and sp.im(sol.evalf()) == 0):
                    # Use high precision evaluation
                    # 
                    val_precise = sol.evalf(self.precision)
                    # Check if imaginary part is negligible
                    # 
                    if hasattr(val_precise, 'as_real_imag'):
                        real_part, imag_part = val_precise.as_real_imag()
                        if abs(float(imag_part)) < self.epsilon:
                            val = float(real_part)
                            real_solutions.append(val)
                    else:
                        val = float(val_precise)
                        real_solutions.append(val)
            except (ValueError, TypeError, AttributeError) as e:
                # Skip solutions that can't be converted to float
                # 
                print(f"  Skipping solution {sol}: conversion error ({e})")
                print(f"   {sol}:  ({e})")
                continue

        if not real_solutions:
            raise ExecutionError(
                f"No real solution found for {target_var}. Solutions: {solutions}\n"
                f" {target_var} : {solutions}"
            )

        print(f"  Found {len(real_solutions)} real solution(s): {real_solutions}")
        print(f"   {len(real_solutions)} : {real_solutions}")

        # Apply physical constraints to filter solutions
        # 
        physical_solutions = []

        # Define variables that should be non-negative
        # 
        non_negative_vars = {
            # Time variables / 
            't', 'time', 'time_interval', 'Δt', 'delta_t',
            # Mass and density / 
            'm', 'mass', 'rho', 'ρ', 'density',
            # Distance and displacement (magnitude) / 
            'd', 'distance', 'h', 'height', 'r', 'radius',
            # Energy / 
            'E', 'energy', 'KE', 'kinetic_energy',
            # Volume and area / 
            'V', 'volume', 'A', 'area',
            # Speed (not velocity, which can be negative) / 
            'speed',
            # Other positive quantities / 
            'frequency', 'wavelength', 'period'
        }

        # Variables that should be strictly positive (> 0, not just >= 0)
        # > 0 >= 0
        strictly_positive_vars = {
            'm', 'mass', 'rho', 'ρ', 'density', 'r', 'radius',
            'V', 'volume', 'A', 'area', 'frequency', 'wavelength', 'period'
        }

        for sol in real_solutions:
            is_valid = True

            # Check if variable should be non-negative
            # 
            if equation_var in non_negative_vars or target_var.lower() in non_negative_vars:
                if equation_var in strictly_positive_vars or target_var.lower() in strictly_positive_vars:
                    # Use epsilon for comparison to handle numerical errors
                    #  epsilon 
                    if sol <= self.epsilon:
                        print(f"  Rejecting solution {sol} (must be strictly positive)")
                        print(f"   {sol} ()")
                        is_valid = False
                else:
                    if sol < -self.epsilon:
                        print(f"  Rejecting solution {sol} (must be non-negative)")
                        print(f"   {sol} ()")
                        is_valid = False
                    elif -self.epsilon <= sol < 0:
                        # Treat very small negative values as zero
                        # 
                        print(f"  Adjusting solution {sol} to 0 (within tolerance)")
                        print(f"   {sol}  0")
                        sol = 0.0

            # Additional sanity checks
            # 
            # Check for extremely large or small values (potential overflow/underflow)
            # /
            if abs(sol) > 1e308 or (abs(sol) < 1e-308 and sol != 0):
                print(f"  Rejecting solution {sol} (out of numerical range)")
                print(f"   {sol} ()")
                is_valid = False

            if is_valid:
                physical_solutions.append(sol)

        if not physical_solutions:
            raise ExecutionError(
                f"No physically valid solution found for {target_var}. "
                f"Real solutions: {real_solutions}\n"
                f" {target_var} "
                f": {real_solutions}"
            )

        # If multiple valid solutions, prefer the one closest to existing values or positive
        # 
        if len(physical_solutions) > 1:
            print(f"  Multiple valid solutions: {physical_solutions}")
            print(f"  : {physical_solutions}")

            # Prefer positive solutions for most physical quantities
            # 
            positive_solutions = [s for s in physical_solutions if s > 0]
            if positive_solutions:
                # Choose the smallest positive solution (often more physically reasonable)
                # 
                selected = min(positive_solutions, key=abs)
                print(f"  Selected positive solution: {selected}")
                print(f"  : {selected}")
                return selected
            else:
                # If no positive solutions, choose the one with smallest absolute value
                # 
                selected = min(physical_solutions, key=abs)
                print(f"  Selected solution with smallest magnitude: {selected}")
                print(f"  : {selected}")
                return selected

        return physical_solutions[0]

    def _evaluate_expression(
        self,
        target: str,
        rule: str,
        input_values: Dict[str, Union[float, int]]
    ) -> Union[float, int]:
        """
        Evaluate an expression directly when all variables are known.
        

        Args:
            target: The variable to compute
                    
            rule: The equation or formula
                  
            input_values: Dictionary of known variable values
                          

        Returns:
            The numerical result
            

        Raises:
            ExecutionError: If the expression cannot be evaluated
                            
        """
        try:
            # Parse the equation
            # 
            equation = self._parse_equation(rule)
            print(f"  Evaluating expression: {equation}")
            print(f"  : {equation}")

            # Extract the expression for the target variable
            # 
            import re
            equation_vars = set(re.findall(r'[Δθπρσμλφψωαβγδεζηικνξοτυχρ]+[a-zA-Z_0-9]*|[a-zA-Z_][a-zA-Z0-9_]*', equation, re.UNICODE))

            # Create SymPy symbols
            #  SymPy 
            symbols_dict = self._create_symbols(equation, target, input_values)

            # Parse the equation
            # 
            if "=" in equation:
                lhs, rhs = equation.split("=", 1)
                lhs = lhs.strip()
                rhs = rhs.strip()

                # Find which side contains the target variable
                # 
                eq_target = self._find_variable_in_equation(target, equation_vars)
                if eq_target:
                    if eq_target in lhs and eq_target not in rhs:
                        # Target is on left side, evaluate right side
                        # 
                        expr_str = rhs
                    elif eq_target in rhs and eq_target not in lhs:
                        # Target is on right side, evaluate left side
                        # 
                        expr_str = lhs
                    else:
                        # Target appears on both sides or neither, can't evaluate directly
                        # 
                        raise ExecutionError(
                            f"Cannot evaluate: target variable '{target}' appears on both sides or is missing\n"
                            f" '{target}' "
                        )
                else:
                    # Assume right side is the expression
                    # 
                    expr_str = rhs
            else:
                # No equation, treat entire rule as expression
                # 
                expr_str = equation

            # Parse expression
            # 
            expr = sp.sympify(expr_str, locals=symbols_dict)
            print(f"  Expression: {expr}")
            print(f"  : {expr}")

            # Substitute known values
            # 
            for var_name, var_value in input_values.items():
                eq_var = self._find_variable_in_equation(var_name, equation_vars)
                if eq_var and eq_var in symbols_dict:
                    expr = expr.subs(symbols_dict[eq_var], var_value)
                    print(f"  Substituted: {var_name} ({eq_var}) = {var_value}")
                    print(f"  : {var_name} ({eq_var}) = {var_value}")

            # Also substitute from self.variables
            #  self.variables 
            for var_name, var_value in self.variables.items():
                if var_name not in input_values:
                    eq_var = self._find_variable_in_equation(var_name, equation_vars)
                    if eq_var and eq_var in symbols_dict:
                        expr = expr.subs(symbols_dict[eq_var], var_value)
                        print(f"  Auto-substituted: {var_name} ({eq_var}) = {var_value}")
                        print(f"  : {var_name} ({eq_var}) = {var_value}")

            # Evaluate the expression
            # 
            result = float(expr.evalf())
            print(f"  Evaluated result: {result}")
            print(f"  : {result}")

            return result

        except ExecutionError:
            # Re-raise ExecutionErrors as-is
            #  ExecutionError
            raise
        except sp.SympifyError as e:
            raise ExecutionError(
                f"Failed to parse expression for '{target}'.\n"
                f"Rule: {rule}\n"
                f"Parse error: {e}\n"
                f"Hint: Check expression syntax.\n"
                f" '{target}' \n"
                f": {rule}\n"
                f": {e}\n"
                f": "
            )
        except (ValueError, TypeError) as e:
            raise ExecutionError(
                f"Failed to evaluate expression for '{target}'.\n"
                f"Rule: {rule}\n"
                f"Input values: {input_values}\n"
                f"Available variables: {list(self.variables.keys())}\n"
                f"Error: {e}\n"
                f"Hint: Ensure all required variables have been computed.\n"
                f" '{target}' \n"
                f": {rule}\n"
                f": {input_values}\n"
                f": {list(self.variables.keys())}\n"
                f": {e}\n"
                f": "
            )
        except Exception as e:
            raise ExecutionError(
                f"Unexpected error evaluating expression for '{target}'.\n"
                f"Rule: {rule}\n"
                f"Input values: {input_values}\n"
                f"Error type: {type(e).__name__}\n"
                f"Error: {e}\n"
                f" '{target}' \n"
                f": {rule}\n"
                f": {input_values}\n"
                f": {type(e).__name__}\n"
                f": {e}"
            )

    def _simplify_expression(
        self,
        target: str,
        rule: str,
        input_values: Dict[str, Union[float, int]]
    ) -> Union[float, int, str]:
        """
        Simplify an expression symbolically and then evaluate if possible.
        

        Args:
            target: The variable to simplify
                    
            rule: The equation or formula
                  
            input_values: Dictionary of known variable values
                          

        Returns:
            The simplified result (numerical if all variables known, symbolic otherwise)
            

        Raises:
            ExecutionError: If the expression cannot be simplified
                            
        """
        try:
            # Parse the equation
            # 
            equation = self._parse_equation(rule)
            print(f"  Simplifying expression: {equation}")
            print(f"  : {equation}")

            import re
            equation_vars = set(re.findall(r'[Δθπρσμλφψωαβγδεζηικνξοτυχρ]+[a-zA-Z_0-9]*|[a-zA-Z_][a-zA-Z0-9_]*', equation, re.UNICODE))

            # Create SymPy symbols
            #  SymPy 
            symbols_dict = self._create_symbols(equation, target, input_values)

            # Parse the equation
            # 
            if "=" in equation:
                lhs, rhs = equation.split("=", 1)
                expr_str = rhs.strip()
            else:
                expr_str = equation

            # Parse and simplify
            # 
            expr = sp.sympify(expr_str, locals=symbols_dict)
            simplified = sp.simplify(expr)
            print(f"  Simplified: {simplified}")
            print(f"  : {simplified}")

            # Substitute known values
            # 
            for var_name, var_value in input_values.items():
                eq_var = self._find_variable_in_equation(var_name, equation_vars)
                if eq_var and eq_var in symbols_dict:
                    simplified = simplified.subs(symbols_dict[eq_var], var_value)

            # Try to evaluate to a number
            # 
            try:
                result = float(simplified.evalf())
                print(f"  Final result: {result}")
                print(f"  : {result}")
                return result
            except (ValueError, TypeError):
                # Return symbolic result as string
                # 
                result_str = str(simplified)
                print(f"  Symbolic result: {result_str}")
                print(f"  : {result_str}")
                return result_str

        except ExecutionError:
            # Re-raise ExecutionErrors as-is
            #  ExecutionError
            raise
        except sp.SympifyError as e:
            raise ExecutionError(
                f"Failed to parse expression for simplification of '{target}'.\n"
                f"Rule: {rule}\n"
                f"Parse error: {e}\n"
                f"Hint: Check expression syntax.\n"
                f" '{target}' \n"
                f": {rule}\n"
                f": {e}\n"
                f": "
            )
        except Exception as e:
            raise ExecutionError(
                f"Error simplifying expression for '{target}'.\n"
                f"Rule: {rule}\n"
                f"Input values: {input_values}\n"
                f"Error type: {type(e).__name__}\n"
                f"Error: {e}\n"
                f" '{target}' \n"
                f": {rule}\n"
                f": {input_values}\n"
                f": {type(e).__name__}\n"
                f": {e}"
            )

    def _validate_result(
        self,
        target: str,
        result: Union[float, int, str],
        input_values: Dict[str, Union[float, int]]
    ) -> None:
        """
        Validate the computed result for physical reasonableness.
        

        Args:
            target: The target variable name
                    
            result: The computed result
                    
            input_values: The input values used in computation
                          

        Raises:
            ExecutionError: If the result is physically unreasonable
                            
        """
        # Skip validation for non-numeric results
        # 
        if isinstance(result, str):
            return

        # Check for NaN or Infinity
        #  NaN 
        if not isinstance(result, (int, float)):
            return

        import math
        if math.isnan(result):
            raise ExecutionError(
                f"Invalid result for {target}: NaN (Not a Number)\n"
                f"{target} : NaN"
            )

        if math.isinf(result):
            raise ExecutionError(
                f"Invalid result for {target}: Infinity\n"
                f"{target} : "
            )

        # Physical range checks
        # 
        warnings = []

        # Check for unreasonably large values
        # 
        if abs(result) > 1e100:
            warnings.append(
                f"Warning: {target} = {result} is extremely large. This may indicate an error.\n"
                f": {target} = {result} "
            )

        # Check for unreasonably small non-zero values
        # 
        if 0 < abs(result) < 1e-100:
            warnings.append(
                f"Warning: {target} = {result} is extremely small. This may indicate an error.\n"
                f": {target} = {result} "
            )

        # Domain-specific checks
        # 
        target_lower = target.lower()

        # Speed of light check (if dealing with velocities)
        # 
        if 'velocity' in target_lower or 'speed' in target_lower or target in ['v', 'v_f', 'v_i']:
            c = 299792458  # Speed of light in m/s / m/s
            if abs(result) > c:
                warnings.append(
                    f"Warning: {target} = {result} exceeds the speed of light ({c} m/s). "
                    f"Check if this is expected for your problem.\n"
                    f": {target} = {result}  ({c} m/s)"
                    f""
                )

        # Temperature checks (if in Kelvin, should be non-negative)
        # 
        if 'temperature' in target_lower or target in ['T', 'temp']:
            if result < 0:
                warnings.append(
                    f"Warning: {target} = {result} is negative. "
                    f"If this is absolute temperature (Kelvin), it's physically impossible.\n"
                    f": {target} = {result} "
                    f""
                )

        # Energy checks (should generally be non-negative for kinetic/potential energy)
        # /
        if target in ['KE', 'kinetic_energy', 'PE', 'potential_energy']:
            if result < 0:
                warnings.append(
                    f"Warning: {target} = {result} is negative. "
                    f"Kinetic and potential energies are typically non-negative.\n"
                    f": {target} = {result} "
                    f""
                )

        # Mass/density checks (should be positive)
        # /
        if target_lower in ['mass', 'm', 'density', 'rho', 'ρ']:
            if result <= 0:
                warnings.append(
                    f"Warning: {target} = {result} is non-positive. "
                    f"Mass and density must be positive.\n"
                    f": {target} = {result} "
                    f""
                )

        # Consistency checks with inputs
        # 
        # Check if result is much larger than all inputs (order of magnitude)
        # 
        if input_values:
            max_input = max(abs(v) for v in input_values.values() if isinstance(v, (int, float)))
            if max_input > 0 and abs(result) > max_input * 1e6:
                warnings.append(
                    f"Warning: {target} = {result} is much larger (>1e6x) than input values. "
                    f"This may indicate a calculation error.\n"
                    f": {target} = {result} >1e6"
                    f""
                )

        # Print warnings but don't raise errors
        # 
        for warning in warnings:
            print(f"  {warning}")

    def _parse_equation(self, rule: str) -> str:
        """
        Extract the equation from a rule description.


        Args:
            rule: The rule string (e.g., "F = m * a" or "Force = mass * acceleration (F = m * a)")
                   "F = m * a"  "Force = mass * acceleration (F = m * a)"

        Returns:
            The equation string

        """
        # Try to find equation in parentheses
        #
        import re
        match = re.search(r'\((.*?=.*?)\)', rule)
        if match:
            equation = match.group(1)
        elif "=" in rule:
            # Otherwise, assume the entire rule is the equation
            #
            equation = rule
        else:
            raise ExecutionError(
                f"Cannot extract equation from rule: {rule}\n"
                f": {rule}"
            )

        # Normalize mathematical symbols for SymPy compatibility
        # SymPy
        # Replace various multiplication symbols with *
        # *
        equation = equation.replace('×', '*')  # U+00D7 multiplication sign
        equation = equation.replace('·', '*')  # U+00B7 middle dot
        equation = equation.replace('∙', '*')  # U+2219 bullet operator
        # Replace division symbols with /
        # /
        equation = equation.replace('÷', '/')  # U+00F7 division sign
        # Replace exponentiation symbol ^ with **
        # ^ **
        equation = equation.replace('^', '**')  # Power operator

        # Normalize function names to SymPy conventions
        # SymPy
        equation = equation.replace('arcsin', 'asin')
        equation = equation.replace('arccos', 'acos')
        equation = equation.replace('arctan', 'atan')
        equation = equation.replace('arccot', 'acot')
        equation = equation.replace('arcsec', 'asec')
        equation = equation.replace('arccsc', 'acsc')

        return equation

    def _get_variable_mapping(self) -> Dict[str, str]:
        """
        Get common variable name mappings (abbreviation -> full name).
         -> 

        Returns:
            Dictionary mapping abbreviations to full names
            
        """
        return {
            # Physics variables - Mechanics /  - 
            'F': 'force',
            'f': 'force',
            'F_net': 'net_force',
            'F_g': 'gravitational_force',
            'F_N': 'normal_force',
            'F_f': 'friction_force',
            'm': 'mass',
            'a': 'acceleration',
            'v': 'velocity',
            'v_f': 'final_velocity',
            'v_i': 'initial_velocity',
            'v0': 'initial_velocity',
            'v1': 'final_velocity',
            'vf': 'final_velocity',
            'vi': 'initial_velocity',
            'u': 'initial_velocity',
            't': 'time',
            'd': 'distance',
            's': 'displacement',
            'x': 'position',
            'y': 'height',
            'h': 'height',
            'g': 'gravity',

            # Energy and Work / 
            'E': 'energy',
            'KE': 'kinetic_energy',
            'PE': 'potential_energy',
            'U': 'potential_energy',
            'W': 'work',
            'P': 'power',
            'Q': 'heat',

            # Momentum / 
            'p': 'momentum',
            'p_i': 'initial_momentum',
            'p_f': 'final_momentum',
            'J': 'impulse',

            # Rotational / 
            'I': 'moment_of_inertia',
            'L': 'angular_momentum',
            'tau': 'torque',
            'τ': 'torque',

            # Thermodynamics / 
            'T': 'temperature',
            'T_i': 'initial_temperature',
            'T_f': 'final_temperature',
            'n': 'mole',
            'R': 'gas_constant',
            'c': 'specific_heat',
            'C': 'heat_capacity',

            # Fluid Mechanics / 
            'rho': 'density',
            'ρ': 'density',
            'V': 'volume',
            'A': 'area',
            'r': 'radius',
            'l': 'length',
            'L': 'length',

            # Waves and Optics / 
            'lambda': 'wavelength',
            'λ': 'wavelength',
            'f': 'frequency',
            'nu': 'frequency',
            'ν': 'frequency',
            'c': 'wave_speed',
            'n': 'refractive_index',

            # Electricity and Magnetism / 
            'q': 'charge',
            'Q': 'charge',
            'I': 'current',
            'V': 'voltage',
            'R': 'resistance',
            'C': 'capacitance',
            'E': 'electric_field',
            'B': 'magnetic_field',
            'Phi': 'magnetic_flux',
            'Φ': 'magnetic_flux',

            # Greek letter variables / 
            'Δv': 'velocity_change',
            'ΔU': 'internal_energy_change',
            'Δt': 'time_interval',
            'Δx': 'displacement',
            'ΔE': 'energy_change',
            'ΔT': 'temperature_change',
            'Δp': 'momentum_change',
            'θ': 'angle',
            'ω': 'angular_velocity',
            'α': 'angular_acceleration',
            'β': 'beta',
            'γ': 'gamma',
            'μ': 'coefficient',
            'σ': 'sigma',
            'phi': 'phi',
            'φ': 'phi',
            'psi': 'psi',
            'ψ': 'psi',

            # Reverse mappings / 
            'force': 'F',
            'net_force': 'F_net',
            'gravitational_force': 'F_g',
            'normal_force': 'F_N',
            'friction_force': 'F_f',
            'mass': 'm',
            'acceleration': 'a',
            'velocity': 'v',
            'final_velocity': 'v_f',
            'initial_velocity': 'v_i',
            'time': 't',
            'distance': 'd',
            'displacement': 's',
            'position': 'x',
            'energy': 'E',
            'kinetic_energy': 'KE',
            'potential_energy': 'PE',
            'momentum': 'p',
            'initial_momentum': 'p_i',
            'final_momentum': 'p_f',
            'impulse': 'J',
            'work': 'W',
            'power': 'P',
            'heat': 'Q',
            'temperature': 'T',
            'initial_temperature': 'T_i',
            'final_temperature': 'T_f',
            'volume': 'V',
            'area': 'A',
            'radius': 'r',
            'height': 'h',
            'length': 'L',
            'gravity': 'g',
            'density': 'rho',
            'wavelength': 'λ',
            'frequency': 'f',
            'charge': 'q',
            'current': 'I',
            'voltage': 'V',
            'resistance': 'R',
            'capacitance': 'C',
            'electric_field': 'E',
            'magnetic_field': 'B',
            'magnetic_flux': 'Φ',
            'moment_of_inertia': 'I',
            'angular_momentum': 'L',
            'torque': 'τ',

            # Reverse mappings for Greek letters / 
            'velocity_change': 'Δv',
            'internal_energy_change': 'ΔU',
            'delta_u_ab': 'ΔU',
            'time_interval': 'Δt',
            'energy_change': 'ΔE',
            'temperature_change': 'ΔT',
            'momentum_change': 'Δp',
            'angle': 'θ',
            'angular_velocity': 'ω',
            'angular_acceleration': 'α',
            'coefficient': 'μ'
        }

    def _find_variable_in_equation(
        self,
        var_name: str,
        equation_vars: set
    ) -> Optional[str]:
        """
        Find the actual variable name used in the equation.
        

        Args:
            var_name: The variable name to find
                      
            equation_vars: Set of variable names in the equation
                          

        Returns:
            The matching variable name in the equation, or None
             None
        """
        # Direct match / 
        if var_name in equation_vars:
            return var_name

        # Try mapping / 
        mapping = self._get_variable_mapping()

        # Check if var_name has a mapped abbreviation in equation
        #  var_name 
        if var_name in mapping and mapping[var_name] in equation_vars:
            return mapping[var_name]

        # Check if any abbreviation of var_name is in equation
        #  var_name 
        for abbr, full in mapping.items():
            if full == var_name and abbr in equation_vars:
                return abbr

        return None

    def _create_symbols(
        self,
        equation: str,
        target: str,
        input_values: Dict[str, Union[float, int]]
    ) -> Dict[str, sp.Symbol]:
        """
        Create SymPy symbols for all variables in an equation.
         SymPy

        Args:
            equation: The equation string

            target: The target variable

            input_values: Known variable values


        Returns:
            Dictionary mapping variable names to SymPy symbols
             SymPy
        """
        import re

        # Extract all variable names: Greek letters (with optional suffix) OR regular identifiers
        #
        var_names = set(re.findall(r'[Δθπρσμλφψωαβγδεζηικνξοτυχρ]+[a-zA-Z_0-9]*|[a-zA-Z_][a-zA-Z0-9_]*', equation, re.UNICODE))

        # Filter out mathematical functions and constants
        #
        math_functions = {
            'sin', 'cos', 'tan', 'cot', 'sec', 'csc',
            'asin', 'acos', 'atan', 'atan2', 'acot', 'asec', 'acsc',
            'arcsin', 'arccos', 'arctan', 'arccot', 'arcsec', 'arccsc',  # Alternative names
            'sinh', 'cosh', 'tanh', 'coth', 'sech', 'csch',
            'asinh', 'acosh', 'atanh', 'acoth', 'asech', 'acsch',
            'log', 'ln', 'log10', 'log2', 'exp',
            'sqrt', 'cbrt', 'root',
            'abs', 'sign', 'floor', 'ceil', 'round',
            'min', 'max', 'sum', 'prod',
            'pi', 'e', 'inf', 'nan',
            'I', 'E', 'Pi', 'Infinity', 'NaN'
        }
        var_names = var_names - math_functions

        # Create symbols
        #
        symbols_dict = {}
        for var_name in var_names:
            symbols_dict[var_name] = sp.Symbol(var_name, real=True)

        # Ensure target and all input variables have symbols
        #
        if target not in symbols_dict:
            symbols_dict[target] = sp.Symbol(target, real=True)

        for var_name in input_values.keys():
            if var_name not in symbols_dict:
                symbols_dict[var_name] = sp.Symbol(var_name, real=True)

        return symbols_dict

    def get_final_answer(self, target_variable: str) -> Optional[Union[float, int]]:
        """
        Retrieve the final answer for the target variable.
        

        Args:
            target_variable: The name of the target variable
                             

        Returns:
            The computed value, or None if not found
             None
        """
        return self.variables.get(target_variable)

    def get_all_results(self) -> Dict[str, Union[float, int]]:
        """
        Get all computed results.
        

        Returns:
            Dictionary of all variable values
            
        """
        return self.variables.copy()


# Example usage / 
if __name__ == "__main__":
    # Test scaffold / 
    test_scaffold = {
        "target_variable": "final_velocity",
        "knowns": {
            "mass": 10,
            "force": 50,
            "time": 5,
            "initial_velocity": 0
        },
        "causal_graph": [
            {
                "cause": ["force", "mass"],
                "effect": "acceleration",
                "rule": "Newton's Second Law (F = m * a)"
            },
            {
                "cause": ["initial_velocity", "acceleration", "time"],
                "effect": "final_velocity",
                "rule": "Kinematic Equation (v_f = v_i + a * t)"
            }
        ],
        "computation_plan": [
            {
                "id": "step1",
                "operation": "solve_for",
                "target": "acceleration",
                "inputs": ["force", "mass"],
                "tool": "symbolic_solver"
            },
            {
                "id": "step2",
                "operation": "solve_for",
                "target": "final_velocity",
                "inputs": ["initial_velocity", "acceleration", "time"],
                "tool": "symbolic_solver"
            }
        ]
    }

    # Execute / 
    executor = SymbolicExecutor()
    result = executor.execute_plan(test_scaffold)

    if result:
        print("\n--- Executed Scaffold ---")
        print(f"Final Answer: {result.get('final_answer')}")
        print(f": {result.get('final_answer')}")
        print(f"\nAll Results: {result.get('results')}")
        print(f": {result.get('results')}")
